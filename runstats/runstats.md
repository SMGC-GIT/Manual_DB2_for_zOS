# üìò Diagn√≥stico com Foco em RUNSTATS no DB2 for z/OS

> **Se√ß√£o do Manual**: `04.03.1 ‚Äì Diagn√≥stico com foco em RUNSTATS`

---

## üìë √çndice

- [üéØ Objetivo](#-objetivo)
- [‚úÖ Perguntas Relevantes sobre o RUNSTATS](#-perguntas-relevantes-sobre-o-runstats)
  - [1. Qual foi o comando exato utilizado no RUNSTATS?](#1-qual-foi-o-comando-exato-utilizado-no-runstats)
  - [2. Foi utilizado FREQVAL, HISTOGRAM ou KEYCARD?](#2-foi-utilizado-freqval-histogram-ou-keycard)
  - [3. As estat√≠sticas foram coletadas para todas as colunas de filtro?](#3-as-estat√≠sticas-foram-coletadas-para-todas-as-colunas-de-filtro)
  - [4. Foi feita coleta para COLGROUPs (colunas combinadas)?](#4-foi-feita-coleta-para-colgroups-colunas-combinadas)
  - [5. Foi feito REBIND com EXPLAIN ap√≥s o RUNSTATS?](#5-foi-feito-rebind-com-explain-ap√≥s-o-runstats)
  - [6. O plano de acesso mudou ap√≥s RUNSTATS + REBIND?](#6-o-plano-de-acesso-mudou-ap√≥s-runstats--rebind)
- [‚ùó Se o RUNSTATS N√£o Resolver](#-se-o-runstats-n√£o-resolver)
- [üìå Exemplo de RUNSTATS Ideal](#-exemplo-de-runstats-ideal)

---

## üéØ Objetivo

O comando `RUNSTATS` √© uma das ferramentas mais importantes para performance no DB2 for z/OS, pois alimenta o otimizador com informa√ß√µes reais sobre os dados (distribui√ß√£o, cardinalidade, frequ√™ncia etc.). Esta se√ß√£o oferece um roteiro detalhado para diagn√≥stico de problemas de performance causados por estat√≠sticas desatualizadas, mal coletadas ou ausentes ‚Äî com foco em **efici√™ncia de plano de acesso** e impacto direto em **sistemas cr√≠ticos em produ√ß√£o**.

---

## ‚úÖ Perguntas Relevantes sobre o RUNSTATS

---

### 1. Qual foi o comando exato utilizado no RUNSTATS?

**O que perguntar:**
> Qual foi o comando completo executado no RUNSTATS? Usaram `FREQVAL`, `KEYCARD`, `HISTOGRAM`?

**Por que isso importa:**
- Um comando simplificado como `RUNSTATS TABLE(ALL)` √© insuficiente.
- Sem op√ß√µes adicionais, o otimizador assume distribui√ß√£o uniforme dos dados, o que raramente √© verdade em produ√ß√£o.
- A falta de op√ß√µes detalhadas **prejudica a seletividade calculada**, levando a planos ruins, como *table space scan* desnecess√°rio.

**Consequ√™ncias t√©cnicas:**
- Filtros mal interpretados;
- Uso de √≠ndices inadequados;
- Substitui√ß√£o de *Nested Loop* por *Merge Join* ou *Hybrid Join* sem necessidade.

---

### 2. Foi utilizado `FREQVAL`, `HISTOGRAM` ou `KEYCARD`?

**Significado t√©cnico:**
- `FREQVAL`: coleta os valores **mais frequentes** de colunas, √∫til quando h√° concentra√ß√£o em poucos valores (ex: status 'A').
- `HISTOGRAM`: divide os dados em **intervalos de frequ√™ncia**, essencial quando h√° **distribui√ß√£o desigual**.
- `KEYCARD`: atualiza a cardinalidade das chaves de √≠ndice, usada para avaliar seletividade e custo de index access.

**Impacto real:**
- Sem `FREQVAL` e `HISTOGRAM`, o otimizador **n√£o reconhece valores dominantes ou raros**.
- Sem `KEYCARD`, ele pode subestimar ou superestimar o custo de usar o √≠ndice ‚Äî levando ao **uso indevido de full scan**.

---

### 3. As estat√≠sticas foram coletadas para todas as colunas de filtro?

**Exemplo de m√° pr√°tica comum:**
> A query filtra por `DATA_VENCIMENTO`, que **n√£o est√° em nenhum √≠ndice** e n√£o foi inclu√≠da no RUNSTATS.

**Resultado:**
- O otimizador assume uma distribui√ß√£o uniforme;
- A estimativa de linhas retornadas fica incorreta;
- A performance se degrada.

**Como resolver:**
> Usar:
```sql
FREQVAL NUMCOLS 1 ON COLUMNS(DATA_VENCIMENTO)
```

**Observa√ß√£o:**  
Mesmo colunas fora dos √≠ndices **devem ter estat√≠sticas**, se participarem de filtros, joins ou condi√ß√µes.

---

### 4. Foi feita coleta para COLGROUPs (colunas combinadas)?

**O que √©:**
- `COLGROUP` permite que o DB2 colete estat√≠sticas sobre **combina√ß√µes de colunas**, essencial quando a query filtra por m√∫ltiplas colunas simultaneamente.

**Problema comum:**
- O otimizador assume que os filtros s√£o **estatisticamente independentes**, o que gera erros grosseiros de estimativa.

**Exemplo pr√°tico:**
```sql
COLGROUP(COD_AGENCIA, COD_PRODUTO) FREQVAL NUMCOLS 2
```

**Sem isso, consequ√™ncias poss√≠veis:**
- Plano de acesso ineficiente;
- *Nested Loop* com cardinalidade errada;
- Joins com tabela errada como "outer".

---

### 5. Foi feito REBIND com EXPLAIN ap√≥s o RUNSTATS?

**Por que isso √© fundamental:**
- O otimizador **s√≥ reavalia o plano de acesso** depois de um REBIND.
- Mesmo com estat√≠sticas atualizadas, se n√£o houver REBIND, o plano antigo ser√° mantido.

**O que √© esperado:**
```sql
REBIND PACKAGE(CONTROLE.ROTINAXX) EXPLAIN(YES) APREUSE(WARN)
```

**Par√¢metros importantes:**
- `EXPLAIN(YES)`: grava o novo plano na `DSN_STATEMNT_TABLE` ou `PLAN_TABLE`.
- `APREUSE(WARN)`: tenta reaproveitar o plano antigo, mas permite substitui√ß√£o caso n√£o seja mais eficiente.

**Consequ√™ncias da aus√™ncia de REBIND:**
- O sistema continua usando um **plano obsoleto**, mesmo com estat√≠sticas novas;
- Diagn√≥stico pode parecer ‚Äúineficaz‚Äù, quando na verdade o REBIND foi omitido.

---

### 6. O plano de acesso mudou ap√≥s RUNSTATS + REBIND?

**Por que perguntar:**
- Se o plano **n√£o mudou**, as estat√≠sticas podem ter sido in√≥cuas (mal coletadas ou irrelevantes).
- Se o plano **mudou e piorou**, pode indicar:
  - Falta de `COLGROUP`;
  - Falta de valores frequentes;
  - Cardinalidade incorreta;
  - Prefer√™ncia indevida por *table scan* ou *merge join*.

**A√ß√£o imediata:**
- Solicitar novo EXPLAIN da query ap√≥s o REBIND;
- Comparar com plano anterior.

---

## ‚ùó Se o RUNSTATS N√£o Resolver

### Pr√≥ximos passos recomendados:

1. **Analisar EXPLAIN com cautela:**
   - Matching Index Access?
   - Stage 1 ou Stage 2?
   - Tipo de join?

2. **Reescrita da query:**
   - Evitar fun√ß√µes e c√°lculos no WHERE;
   - Reduzir uso de `DISTINCT`, `ORDER BY` se n√£o forem essenciais.

3. **Cria√ß√£o ou ajuste de √≠ndices:**
   - Adi√ß√£o de colunas com `INCLUDE`;
   - Novo √≠ndice composto.

4. **Novo RUNSTATS com COLGROUP e HISTOGRAM:**
   - Refor√ßa o conhecimento do otimizador sobre dados combinados.

5. **Uso de REOPT(ALWAYS):**
   - Caso a query use par√¢metros din√¢micos com varia√ß√£o alta.

---

## üìå Exemplo de RUNSTATS Ideal

Este comando simula uma coleta de estat√≠sticas adequada para casos em que h√°:
- Filtros com colunas isoladas e combinadas;
- Presen√ßa de colunas fora dos √≠ndices;
- Distribui√ß√£o desigual dos dados;
- Necessidade de decis√£o baseada em valores mais frequentes.

```sql
RUNSTATS TABLESPACE DBX.TSX 
  TABLE(ALL) 
  INDEX(ALL) 
  KEYCARD 
  FREQVAL NUMCOLS 1 
  FREQVAL NUMCOLS 2 ON COLUMNS(COL1, COL2) 
  HISTOGRAM ON COLUMNS(COL1, COL2)
  REPORT YES
```

### Explica√ß√£o de cada item:

- `TABLESPACE DBX.TSX`: define a tablespace de destino da coleta;
- `TABLE(ALL)`: coleta estat√≠sticas para todas as tabelas do espa√ßo;
- `INDEX(ALL)`: inclui todos os √≠ndices das tabelas;
- `KEYCARD`: atualiza a contagem de chaves distintas dos √≠ndices;
- `FREQVAL NUMCOLS 1`: coleta os valores mais frequentes de colunas individuais (√∫til para filtros simples);
- `FREQVAL NUMCOLS 2 ON COLUMNS(COL1, COL2)`: coleta frequ√™ncia combinada de valores em pares de colunas (essencial para filtros m√∫ltiplos);
- `HISTOGRAM ON COLUMNS(COL1, COL2)`: coleta dados de distribui√ß√£o para identificar valores dominantes e outliers;
- `REPORT YES`: gera um relat√≥rio detalhado para revis√£o das estat√≠sticas geradas.

---

### ‚ö†Ô∏è Dicas importantes:

- Evite usar apenas `RUNSTATS TABLE(ALL) INDEX(ALL)` sem nenhuma personaliza√ß√£o: isso n√£o fornece informa√ß√µes suficientes para o otimizador tomar decis√µes precisas.
- Sempre **fa√ßa REBIND ap√≥s o RUNSTATS**, com `EXPLAIN(YES)`, para garantir que o novo plano seja gerado com base nas estat√≠sticas atualizadas.
- Analise o **novo plano de acesso** com base no `EXPLAIN`, antes de considerar reescrita da query ou cria√ß√£o de novos √≠ndices.
- Use `REPORT YES` para comparar a **cardinalidade estimada vs real** e verificar se a coleta foi suficiente.

---

üìé **Refer√™ncia complementar**:  
- [IBM Docs ‚Äì RUNSTATS Utility (Db2 13 for z/OS)](https://www.ibm.com/docs/en/db2-for-zos/13?topic=utilities-runstats-utility)
- [IBM Redbook ‚Äì Db2 13 Performance Topics](https://www.redbooks.ibm.com/abstracts/sg248551.html)

---

üîö **Conclus√£o da Se√ß√£o**:  
Compreender e aplicar corretamente o `RUNSTATS` √© essencial para garantir a efici√™ncia das queries em ambientes cr√≠ticos. Uma coleta mal feita pode comprometer todo o plano de acesso. Esta se√ß√£o deve ser sempre revisitada antes de partir para altera√ß√µes estruturais no banco ou reescrita de l√≥gica SQL.

---

